Испытание односвязным списком
В недрах большого числа программ таится то, что является программистам в форме односвязных списков. Они просты,  примитивны, но по своему эффективны! Каждый элемент этого списка "цепляется" за следующий посредством указателя *next, кроме последнего, который принимает специальное значение nullptr, означающее конец односвязного списка.

Чтобы знать, где начало, а где конец этой последовательности, ставят маркеры в виде двух указателей:

head - на первый элемент (если его нет, то nullptr);
tail - на последний элемент (если его нет, то nullptr).
Каждый элемент списка представляет собой объект (например, класса или структуры - Object). В каждом таком объекте присутствуют, как минимум, два поля:

data - данные, хранящиеся в текущем элементе (объекте);
*next - указатель на следующий элемент (объект).
Для обращения к этим полям в классе или структуре Object должны быть предусмотрены публичные методы:

get_data(); // получение значения поля data
get_next(); // получение значения поля next
А общее управление всем односвязным списком пусть реализуется в классе OneLinkedList. В этом классе объявляются указатели head и tail, а его общий функционал должен быть таким, чтобы выполнялись следующие действия:

OneLinkedList<Complex> lst; // пустой односвязный список для хранения данных типа Complex (структура)

lst.push_back(Complex {1, 2}); // добавление в конец списка
lst.push_back(Complex {3, 4}); // добавление в конец списка
lst.push_front(Complex {-1, -2}); // добавление в начало списка
lst.pop_back(); // удаление последнего элемента (если его нет, то ничего не делать)
lst.pop_front(); // удаление первого элемента (если его нет, то ничего не делать)

Complex d = lst[0];  // получение первого элемента по индексу
lst[0] = Complex {5, 8}; // запись в первый элемент по индексу

OneLinkedList<int> lst_int; // еще один односвязный список для хранения данных типа int

lst_int.push_back(1); // добавление в конец списка
lst_int.push_back(2);
lst_int.push_back(3);

int var = lst_int[1]; // чтение данных из второго элемента списка
lst_int[2] = -5; // запись данных в третий элемент списка

// перебор первого списка
std::shared_ptr< Object<Complex> > ptr_lst = lst.get_head();
while(ptr_lst) {
    Complex res = ptr_lst->get_data();
    ptr_lst = ptr_lst->get_next();
}

// перебор второго списка
std::shared_ptr< Object<int> > ptr_lst_int = lst_int.get_head();
while(ptr_lst_int) {
    int a = ptr_lst_int->get_data();
    ptr_lst_int = ptr_lst_int->get_next();
}
При реализации операций индексации [] для доступа к несуществующим элементам односвязного списка, следует генерировать исключение типа LinkedListIndexError с сообщением:

"Invalid element index."

Пример использования:

try {
    Complex cmp = lst[-1];
}
catch(const LinkedListIndexError& e) {
    std::cout << e.what() << std::endl;
}
В этом испытании вам необходимо только прописать классы:

Object - для представления отдельных элементов в односвязном списке;
OneLinkedList - для представления односвязного списка в целом;
LinkedListIndexError - класс для генерации исключения.
Что-либо выводить на экран и объявлять функцию main не нужно.

В C++ в библиотеке STL односвязный список уже реализован: std::forward_list
